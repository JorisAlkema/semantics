-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}

module DeBruijn.Abs (module DeBruijn.Abs, module Syntax.Base) where

import Data.Data    (Data, Typeable)
import GHC.Generics (Generic)
import Data.Hashable

import Syntax.Base
import Syntax.PrintClass
import Syntax.Tree
import Data.Tree

data Ident
  = Bound Int String
  | Free String
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

instance Hashable Ident where
  hash (Bound i _) = hash i
  hash (Free x) = hash x

data Exp
    = Var Ident
    | Val Integer
    | BVal BConst
    | App Exp Exp
    | Fst Exp
    | Snd Exp
    | Mul Exp Exp
    | Add Exp Exp
    | Sub Exp Exp
    | Pair Exp Exp
    | BEq Exp Exp
    | BLeq Exp Exp
    | BNeg Neg Exp
    | BAnd Exp And Exp
    | BOr Exp Or Exp
    | Ite Exp Exp Exp
    | Abstr Lam Exp
    | Rec Exp
    | Typed Exp Type
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

instance Treeish Ident where
  toTree (Bound i _) = Node ("<" ++ show i ++ ">") []
  toTree (Free x) = Node x []

instance Treeish Exp where
  toTree x = case x of
    Var ident -> toTree ident
    Val integer -> Node (show integer) []
    BVal bconst -> toTree bconst
    App exp1 exp2 -> Node "app" [toTree exp1, toTree exp2]
    Fst exp -> Node "fst" [toTree exp]
    Snd exp -> Node "snd" [toTree exp]
    Mul exp1 exp2 -> Node "*" [toTree exp1, toTree exp2]
    Add exp1 exp2 -> Node "+" [toTree exp1, toTree exp2]
    Sub exp1 exp2 -> Node "-" [toTree exp1, toTree exp2]
    Pair exp1 exp2 -> Node "pair" [toTree exp1, toTree exp2]
    BEq  exp1 exp2 -> Node "==" [toTree exp1, toTree exp2]
    BLeq exp1 exp2 -> Node "<=" [toTree exp1, toTree exp2]
    BNeg (Neg neg) bexp -> Node neg [toTree bexp]
    BAnd bexp1 (And and) bexp2 -> Node and [toTree bexp1, toTree bexp2]
    BOr  bexp1 (Or or) bexp2 -> Node or [toTree bexp1, toTree bexp2]
    Ite bexp exp1 exp2 -> Node "ite" [toTree bexp, toTree exp1, toTree exp2]
    Abstr lam exp -> Node "Î»" [toTree exp]
    Rec exp -> Node "rec" [toTree exp]
    Typed exp ty -> Node "::"  [toTree exp, toTree ty]

instance Print Ident where
  prt _ (Bound i _) = doc (showString ("<" ++ show i ++ ">"))
  prt _ (Free x)    = doc (showString x)

instance Print Exp where
  prt i e = case e of
    Var id -> prPrec i 10 (concatD [prt 0 id])
    Val n -> prPrec i 10 (concatD [prt 0 n])
    BVal bconst -> prPrec i 10 (concatD [prt 0 bconst])
    App exp1 exp2 -> prPrec i 9 (concatD [prt 9 exp1, prt 10 exp2])
    Fst exp -> prPrec i 9 (concatD [doc (showString "fst"), prt 10 exp])
    Snd exp -> prPrec i 9 (concatD [doc (showString "snd"), prt 10 exp])
    Mul exp1 exp2 -> prPrec i 8 (concatD [prt 8 exp1, doc (showString "*"), prt 9 exp2])
    Add exp1 exp2 -> prPrec i 7 (concatD [prt 7 exp1, doc (showString "+"), prt 8 exp2])
    Sub exp1 exp2 -> prPrec i 7 (concatD [prt 7 exp1, doc (showString "-"), prt 8 exp2])
    Pair exp1 exp2 -> prPrec i 6 (concatD [prt 7 exp1, doc (showString ","), prt 6 exp2])
    BEq exp1 exp2 -> prPrec i 5 (concatD [prt 6 exp1, doc (showString "=="), prt 6 exp2])
    BLeq exp1 exp2 -> prPrec i 5 (concatD [prt 6 exp1, doc (showString "<="), prt 6 exp2])
    BNeg neg exp -> prPrec i 4 (concatD [prt 0 neg, prt 5 exp])
    BAnd exp1 and exp2 -> prPrec i 3 (concatD [prt 3 exp1, prt 0 and, prt 4 exp2])
    BOr exp1 or exp2 -> prPrec i 3 (concatD [prt 3 exp1, prt 0 or, prt 4 exp2])
    Ite exp1 exp2 exp3 -> prPrec i 2 (concatD [doc (showString "if"), prt 3 exp1, doc (showString "then"), prt 6 exp2, doc (showString "else"), prt 2 exp3])
    Abstr lam exp -> prPrec i 1 (concatD [prt 0 lam, doc (showString "."), prt 1 exp])
    Rec exp -> prPrec i 1 (concatD [doc (showString "rec"), doc (showString "."), prt 1 exp])
    Typed exp type_ -> prPrec i 0 (concatD [prt 0 exp, doc (showString "::"), prt 0 type_])
