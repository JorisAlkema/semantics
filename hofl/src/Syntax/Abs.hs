-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}

module Syntax.Abs (module Syntax.Abs, module Syntax.Base) where

import Data.Data    (Data, Typeable)
import GHC.Generics (Generic)

import Syntax.Base
import Syntax.Tree
import Data.Tree
import Syntax.PrintClass

newtype Ident = Ident String
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data Exp
    = Var Ident
    | Val Integer
    | BVal BConst
    | App Exp Exp
    | Fst Exp
    | Snd Exp
    | Mul Exp Exp
    | Add Exp Exp
    | Sub Exp Exp
    | Pair Exp Exp
    | BEq Exp Exp
    | BLeq Exp Exp
    | BNeg Neg Exp
    | BAnd Exp And Exp
    | BOr Exp Or Exp
    | Ite Exp Exp Exp
    | Abstr Lam Ident Exp
    | Rec Ident Exp
    | Typed Exp Type
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data Assignment = Assign Ident Exp
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

data Environment = Env [Assignment]
  deriving (Eq, Ord, Show, Read, Data, Typeable, Generic)

instance Treeish Ident where
  toTree (Ident string) = Node string []

instance Treeish Exp where
  toTree x = case x of
    Var ident -> toTree ident
    Val integer -> Node (show integer) []
    BVal bconst -> toTree bconst
    App exp1 exp2 -> Node "app" [toTree exp1, toTree exp2]
    Fst exp -> Node "fst" [toTree exp]
    Snd exp -> Node "snd" [toTree exp]
    Mul exp1 exp2 -> Node "*" [toTree exp1, toTree exp2]
    Add exp1 exp2 -> Node "+" [toTree exp1, toTree exp2]
    Sub exp1 exp2 -> Node "-" [toTree exp1, toTree exp2]
    Pair exp1 exp2 -> Node "pair" [toTree exp1, toTree exp2]
    BEq  exp1 exp2 -> Node "==" [toTree exp1, toTree exp2]
    BLeq exp1 exp2 -> Node "<=" [toTree exp1, toTree exp2]
    BNeg (Neg neg) bexp -> Node neg [toTree bexp]
    BAnd bexp1 (And and) bexp2 -> Node and [toTree bexp1, toTree bexp2]
    BOr  bexp1 (Or or) bexp2 -> Node or [toTree bexp1, toTree bexp2]
    Ite bexp exp1 exp2 -> Node "ite" [toTree bexp, toTree exp1, toTree exp2]
    Abstr lam ident exp -> Node "Î»" [toTree ident, toTree exp]
    Rec ident exp -> Node "rec" [toTree ident, toTree exp]
    Typed exp ty -> Node "::"  [toTree exp, toTree ty]

instance Print Ident where
  prt _ (Ident i) = doc (showString i)

instance Print Exp where
  prt i e = case e of
    Var id -> prPrec i 10 (concatD [prt 0 id])
    Val n -> prPrec i 10 (concatD [prt 0 n])
    BVal bconst -> prPrec i 10 (concatD [prt 0 bconst])
    App exp1 exp2 -> prPrec i 9 (concatD [prt 9 exp1, prt 10 exp2])
    Fst exp -> prPrec i 9 (concatD [doc (showString "fst"), prt 10 exp])
    Snd exp -> prPrec i 9 (concatD [doc (showString "snd"), prt 10 exp])
    Mul exp1 exp2 -> prPrec i 8 (concatD [prt 8 exp1, doc (showString "*"), prt 9 exp2])
    Add exp1 exp2 -> prPrec i 7 (concatD [prt 7 exp1, doc (showString "+"), prt 8 exp2])
    Sub exp1 exp2 -> prPrec i 7 (concatD [prt 7 exp1, doc (showString "-"), prt 8 exp2])
    Pair exp1 exp2 -> prPrec i 6 (concatD [prt 7 exp1, doc (showString ","), prt 6 exp2])
    BEq exp1 exp2 -> prPrec i 5 (concatD [prt 6 exp1, doc (showString "=="), prt 6 exp2])
    BLeq exp1 exp2 -> prPrec i 5 (concatD [prt 6 exp1, doc (showString "<="), prt 6 exp2])
    BNeg neg exp -> prPrec i 4 (concatD [prt 0 neg, prt 5 exp])
    BAnd exp1 and exp2 -> prPrec i 3 (concatD [prt 3 exp1, prt 0 and, prt 4 exp2])
    BOr exp1 or exp2 -> prPrec i 3 (concatD [prt 3 exp1, prt 0 or, prt 4 exp2])
    Ite exp1 exp2 exp3 -> prPrec i 2 (concatD [doc (showString "if"), prt 3 exp1, doc (showString "then"), prt 6 exp2, doc (showString "else"), prt 2 exp3])
    Abstr lam id exp -> prPrec i 1 (concatD [prt 0 lam, prt 0 id, doc (showString "."), prt 1 exp])
    Rec id exp -> prPrec i 1 (concatD [doc (showString "rec"), prt 0 id, doc (showString "."), prt 1 exp])
    Typed exp type_ -> prPrec i 0 (concatD [prt 0 exp, doc (showString "::"), prt 0 type_])

instance Print Assignment where
  prt i e = case e of
    Assign id exp -> prPrec i 0 (concatD [prt 0 id, doc (showString "="), prt 0 exp])
  prtList _ [] = concatD []
  prtList _ [x] = concatD [prt 0 x]
  prtList _ (x:xs) = concatD [prt 0 x, doc (showString ";"), prt 0 xs]

instance Print [Assignment] where
  prt = prtList

instance Print Environment where
  prt i e = case e of
    Env assignments -> prPrec i 0 (concatD [prt 0 assignments])
