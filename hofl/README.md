# HOFL - A Higher-Order Functional Programming Language

## Syntax

The syntax of HOFL is very similar to that of λY, which we used in the lecture but a
bit more elaborate and user friendly.
The main difference is that HOFL features also Boolean expressions and standard arithmetic
operators.
It also supports integers, and thus untruncated subtraction, natively.

The type are generated by the grammar

A ::= int | bool | A * A | A -> A

In a program, * and -> can also be written as unicode symbols × and →, respectively.
The terms, given by the data type Exp, of the language are generated by the following grammar,
in which x is a variable, n an integer and b a Boolean value.

t ::= x | n | b |
    t t | \x. t |
    fst t | snd t | t , t |
    t * t | t + t | t - t |
    t == t | t <= t | ~ t | t && t | t || t |
    if t then t else t |
    rec x. t |
    t :: A

The second row has the function application and abstraction; the third how projections and pairing
for products; the fourth row arithmetic; the fifth row comparison and logical operator; the sixth
if-then-else; the seventh recursion; and the eighth allows annotating terms with types.

The logical connectives &&, || and ~ also have ∧, ∨ and ¬ as unicode alternative.

## Building and running

You can build the project by running `stack build` in the folder and then run the program
with `stack run -- [program options]`.
Note that the programs options are preceded by `--`, which cannot be left out!
The allowed program options can be displayed with `stack run -- --help`.
Tests can be run with `stack test`.

## Goals of this project

The goal is to implement big-step and denotational semantics of HOFL programs.
You don't have to implement a parser etc., as it is already available.
In the folder `test`, you may find some sample programs to try it out.
For instance, running

    stack run -- test/fibonacci.fl

prints the internal representation of the program as abstract syntax, as better readable syntax
tree and as pretty-printed program.
Like this, you can try to parse various programs.
Note that you can also run the program without arguments and enter an expression through the
standard input and terminating with CTRL-D.

Next, you may try to run

    stack run -- -e b "n=4" test/fibonacci.fl

This command line tries to evaluate (the "-e" flag) the program in `test/fibonacci.fl` with the
big-step semantics (the "b") in with the variable n set to 4.

The first successful parse is that of the empty environment and the second of the given program.
After that, it is indicated that the big-step semantics are not defined for some case in the file
`src/Semantics/BigStep.hs`.

As you can see in that file, there are various maps that implement the different styles of
semantics.
Your task is it now to fill in these maps with the correct semantics of commands etc. in HOFL.

## Correctness

You can run the unit tests with the command

    stack test

The goal is to implement the semantics and pass all the unit tests.

## Implementation

You will have to implement the functions `evalExp` in `Semantics.BigStep` and
`evalExp` in `Semantics.Denotational`, and complete the function `evalBExp` in
`Semantics.ExpEval`.
Each of these functions has undefined cases that throw an error.
To see what you have to fill in, replace any of the occurrences of `failure x` by an
underscore, a so-called [hole](https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/typed_holes.html),
and run `stack build`.
The compiler will tell you now what the type of the expression is that you have to fill in and what
you have in scope.

### De Bruijn Trees

When you run

    stack run -- test/fibonacci.fl

you will get two trees that are printed, with the second one labelled "De Bruijn Tree".
Recall that we allows renaming of variables in λY through identities that hold between terms.
There is another way, see the lecture or lecture notes, namely of positional binding.
The idea is that a bound variable is referred to as `<n>`, which says that we are looking for
the variable that is bound by the nth binder up the tree.
For instance, `<0>` refers to the closest binder.
The translation from syntax into De Bruijn trees is done already and in your implementation,
you will only deal with those.
Note, however, that free variables still use names in form of strings.

To work with De Bruijn tree, you need to consult the module `DeBruijn.Substitution`.
There you find a function called `removeBinder`, which does all the heavy work.
It takes a term of the form `λx. t` or `rec x. t` and another term `s`, and substitutes `s`
for `x` in `t`, that is, `removeBinder (λx. t) s` gives `t[s]`.
This substitution operation is sufficient to implement all the semantics.

### Big-Step Semantics

The goal here is to implement the function `Semantics.BigStep.evalExp` is a function of type
`MonadReader Env m => Exp -> m Value`.
In this type, the type constructor `m` of a `MonadReader` us just used to keep around the
environment that assigns values to free variables in the program.
For example, this is the variable `n` in the Fibonacci program, which is not bound and provided
in the command

    stack run -- -e b "n=4" test/fibonacci.fl

trough the `n=4` portion.
You don't need to know more than that you are working within a monad and thus will have to resort
to `(>>=)`, `pure`, `fmap` and the like or the `do` notation.
In `evalExp`, the monad is only actually used in the case `Free x`, which is already implemented.

More interesting is the type `Value` of values that programs can produce.
These correspond to the values that we introduced in the lecture, extended with Boolean values.
The `VInt`, `VBool`, and `VPair` constructors stand, respectively, for integer, Boolean and pairs
of values.
Recall that a value of function type is a *term* of the form `λx. t` and that we do not further
evaluate these until they are applied to an argument that is then substituted.
The constructor `VThunk` allows us postpone the evaluation of a term and in the case for `App`
in the function `evalExp`, we can use it to store an unevaluated λ-abstraction.
When implementing `evalExp`, keep in mind that only terms of function type should result in a
value given by `VThunk`.

Finally, note that `evalExp` will have to diverge on non-termination HOFL programs, like `rec x. x`.

### Denotational Semantics

The denotational semantics of HOFL builds on the same `Delay` data type that we used already in the
denotational semantics of IMP to model the flat order and thus non-termination.
This type is used to define the type `Domain`, which is used as result of the denotational
semantics and is defined by mutual recursion with the type `Value`.
Note that this type is very different from `BigStep.Value`!
It has again four constructors corresponding to the four type constructors: `VInt` and `VBool`
are as before, `VPair` takes two elements of `Domain` (delayed computations of values), and
`VMap` takes function on `Domain`.
With this, we can interpret function types of HOFL as *Haskell functions* and the term
`λx. t` can then be interpreted as a function `Domain -> Domain`, such that the argument
will be passed to the interpretation of `t` as interpretation of `x`.

Your task is to implement the function `denExp :: Exp -> R Domain`, where `R a = `Env -> a`
and should be read as "result" type.
Note that the `Domain` type differs from the interpretation we give to types in the lecture.
There, we interpreted, for example, `N x N` as `ℕ⊥ x ℕ⊥` but here the elements of product type will
be interpreted as elements `Delay Value` and the value has in turn elements `Delay Value`.
Thus, we add another layer of `Delay` on every type and the interpretation of `N x N` can
be read as `(ℕ⊥ x ℕ⊥)⊥`.

The `Env` argument is the environment that keeps track of the values of variables, which can be
either variables that are free with a regular name or arise from a binder that has been removed.
You can see how the values are retrieved in the pre-filled implementation of `denExp` for the
cases `Var (Bound i _)` and `Var (Free x)`.
You will have to use the map `bindValue` to set and retrieve the values of bound variables when
you implement the denotation of function abstraction and recursion.
There is also a function `thunkMap` that will help you with the former.
