module Syntax.Tree where

-- Haskell module generated by the BNF converter

import Syntax.Abs
import Syntax.ErrM
import Data.Tree
type Result = Tree String

failure :: Show a => a -> Result
failure x = error $ "Undefined case: " ++ show x

class Treeish a where
  toTree :: a -> Tree String

instance Treeish Ident where
  toTree (Ident string) = Node string []

instance Treeish AExp where
  toTree x = case x of
    EInt integer -> Node (show integer) []
    EVar ident -> toTree ident
    ETimes aexp1 aexp2 -> Node "*" [toTree aexp1, toTree aexp2]
    EPlus  aexp1 aexp2 -> Node "+" [toTree aexp1, toTree aexp2]
    ESub   aexp1 aexp2 -> Node "+" [toTree aexp1, toTree aexp2]

instance Treeish BVal where
  toTree x = case x of
    BTrue -> Node "true" []
    BFalse -> Node "false" []

instance Treeish BExp where
  toTree x = case x of
    EVal bval -> toTree bval
    EEq  aexp1 aexp2 -> Node "==" [toTree aexp1, toTree aexp2]
    ELeq aexp1 aexp2 -> Node "<=" [toTree aexp1, toTree aexp2]
    ENeg (Neg neg) bexp -> Node neg [toTree bexp]
    EAnd bexp1 (And and) bexp2 -> Node and [toTree bexp1, toTree bexp2]
    AOr  bexp1 (Or or) bexp2 -> Node or [toTree bexp1, toTree bexp2]

instance Treeish Com where
  toTree x = case x of
    CSkip                  -> Node "skip" []
    CAssign ident aexp     -> Node "assign" [toTree ident, toTree aexp]
    CSeq    com1 com2      -> Node "seq" [toTree com1, toTree com2]
    CIte    bexp com1 com2 -> Node "ite" [toTree bexp, toTree com1, toTree com2]
    CWhile  bexp com       -> Node "while" [toTree bexp, toTree com]
