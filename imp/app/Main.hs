-- automatically generated by BNF Converter
module Main where


import System.IO ( stdin, hGetContents )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )
import Control.Monad (when)
import Data.Tree (drawTree)

import Syntax.Lex
import Syntax.Par
import Syntax.Print
import Syntax.Abs
import Syntax.Tree
import Semantics.Memory
import Semantics.Delay
import Semantics.BigStep as Big
import Semantics.Denotational as Den


import Syntax.ErrM

type ParseFun a = [Token] -> Err a

myLLexer = myLexer

type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: (Print a, Show a, Treeish a) => Verbosity -> ParseFun a -> FilePath -> IO ()
runFile v p f = putStrLn f >> readFile f >>= run v p

run :: (Print a, Show a, Treeish a) => Verbosity -> ParseFun a -> String -> IO ()
run v p s = let ts = myLLexer s in case p ts of
           Bad s    -> do putStrLn "\nParse              Failed...\n"
                          putStrV v "Tokens:"
                          putStrV v $ show ts
                          putStrLn s
                          exitFailure
           Ok  tree -> do putStrLn "\nParse Successful!"
                          showTree v tree

                          exitSuccess

parse :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO a
parse v p s = let ts = myLLexer s in case p ts of
           Bad s    -> do putStrLn "\nParse              Failed...\n"
                          putStrV v "Tokens:"
                          putStrV v $ show ts
                          putStrLn s
                          exitFailure
           Ok  tree -> do putStrLn "\nParse Successful!"
                          return tree


evalFile :: Verbosity -> ParseFun Com -> String -> Env -> FilePath -> IO ()
evalFile v pCom sem env f = putStrLn f >> readFile f >>= eval v pCom sem env

eval :: Verbosity -> ParseFun Com -> String -> Env -> String -> IO ()
eval v pCom sem env prog = do
  com <- parse v pCom prog
  let r = case sem of
            "b"  -> Ok . show . Big.evalCom com $ mkMem env
            "d"  -> Ok . show . pruneDelay 10 show "..." . Den.evalCom com $ mkMem env
            _    -> Bad $ "Unknown semantics \"" ++ sem ++ "\" - should be b"
    in case r of
    Bad s -> do
        putStrLn "Evaluation failed"
        putStrLn s
    Ok s -> putStrLn $ "Evaluation result:" ++ s

-- eval :: Verbosity -> ParseFun Com -> String -> Env -> String -> IO ()
-- eval v pCom sem env prog = do
--   com <- parse v pCom prog
--   let r = case sem of
--             "b"  -> fmap show $ Big.evalCom com $ mkMem env
--             "d"  -> fmap (show . pruneDelay 10 show "...") $ Den.evalCom com $ mkMem env
--             _    -> Bad $ "Unknown semantics \"" ++ sem ++ "\" - should be b"
--     in case r of
--     Bad s -> do
--         putStrLn "Evaluation failed"
--         putStrLn s
--     Ok s -> putStrLn $ "Evaluation result:" ++ s

showTree :: (Show a, Print a, Treeish a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Syntax tree]\n\n"     ++ (drawTree $ toTree tree)
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:"
    , "  --help          Display this help message."
    , "  (no arguments)  Parse stdin verbosely."
    , "  (files)         Parse content of files verbosely."
    , "  -s (files)      Silent mode. Parse content of files silently."
    , "  -e (semantics) (environment) (files)   Parse content of files and evaluate with given"
      ++ "semantics (b - big-step and environment"
    ]
  exitFailure

main :: IO ()
main = do
  args <- getArgs
  case args of
    ["--help"] -> usage
    [] -> getContents >>= run 2 pCom
    "-s":fs -> mapM_ (runFile 0 pCom) fs
    "-e":s:envS:fs -> parse 2 pEnv envS >>= \env -> mapM_ (evalFile 2 pCom s env) fs
    fs -> mapM_ (runFile 2 pCom) fs
